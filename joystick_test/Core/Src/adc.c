/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f303xc.h"
#include <stdlib.h>
#include <stdio.h>
#include "serial.h"
#include "servo.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

uint16_t x_coordinate = 0;
uint16_t y_coordinate = 0;


// enable the clocks for desired peripherals (GPIOA, C and E)
void enable_clocks() {
	RCC->AHBENR |= RCC_AHBENR_GPIOAEN | RCC_AHBENR_GPIOCEN | RCC_AHBENR_GPIOEEN;
}

// initialise the discovery board I/O (just outputs: inputs are selected by default)
void initialise_board() {

	// get a pointer to the second half word of the MODER register (for outputs pe8-15)
	uint16_t *led_output_registers = ((uint16_t *)&(GPIOE->MODER)) + 1;
	*led_output_registers = 0x5555;
}


uint16_t ReadADC(uint32_t channel) {

	ADC1->SQR1 = 0;
	ADC1->SQR1 |= channel << ADC_SQR1_SQ1_Pos; // set the request for channel specified

	// request the process to start
	ADC1->CR |= ADC_CR_ADSTART;

	// Wait for the end of conversion
	while((ADC1->ISR &= ADC_ISR_EOS) != ADC_ISR_EOS);

	return ADC1->DR;
}


void finished_transmission(uint32_t bytes_sent) {
	// This function will be called after a transmission is complete

//	volatile uint32_t test = 0;
//	// make a very simple delay
//	for (volatile uint32_t i = 0; i < 0x100; i++) {
//		// waste time !
//	}
}

void SingleReadMultiChannelADC() {

	// get a pointer to the location of the LEDs
	uint8_t *led_register = ((uint8_t*)&(GPIOE->ODR)) + 1;

	// enable the clock for ADC1
	RCC->AHBENR |= RCC_AHBENR_ADC12EN;

	// set to synchronise the ADC with the clock
	ADC12_COMMON->CCR |= ADC12_CCR_CKMODE_0;

	// ADEN must be = 0 for configuration (is the default)
	ADC1->CR &= ~ADC_CR_ADVREGEN; // clear voltage regulator enable
	ADC1->CR |= ADC_CR_ADVREGEN_0; // set ADVREGEN TO 01
	ADC1->CR &= ~ADC_CR_ADCALDIF; // clear bit to enable Single-ended-input

	ADC2->CR &= ~ADC_CR_ADVREGEN; // clear voltage regulator enable
	ADC2->CR |= ADC_CR_ADVREGEN_0; // set ADVREGEN TO 01
	ADC2->CR &= ~ADC_CR_ADCALDIF; // clear bit to enable Single-ended-input

	// calibrate the ADC (self calibration routine)
	ADC1->CR |= ADC_CR_ADCAL;
	while((ADC1->CR & ADC_CR_ADCAL) == ADC_CR_ADCAL); // Waiting for the calibration to finish

	ADC2->CR |= ADC_CR_ADCAL;
	while((ADC2->CR & ADC_CR_ADCAL) == ADC_CR_ADCAL); // Waiting for the calibration to finish

	// We want to read from two channels each sequence
	//  the first channel goes in SQ1
	//  the second channel goes in SQ2
	//  the number of channels to read = 2, so the L value is 1
	ADC1->SQR1 = 0;
	ADC1->SQR1 |= 0x02 << ADC_SQR1_SQ1_Pos; // set the request for channel 2
	ADC1->SQR1 |= 0x03 << ADC_SQR1_SQ2_Pos; // set the request for channel 3
	ADC1->SQR1 |= 0x01 << ADC_SQR1_L_Pos; // set the number of channels to read

	ADC2->SQR1 = 0;
	ADC2->SQR1 |= 0x02 << ADC_SQR1_SQ1_Pos; // set the request for channel 2
	ADC2->SQR1 |= 0x03 << ADC_SQR1_SQ2_Pos; // set the request for channel 3
	ADC2->SQR1 |= 0x01 << ADC_SQR1_L_Pos; // set the number of channels to read

	// single shot mode
	ADC1->CFGR &= ~ADC_CFGR_CONT;

	// Enable the ADC
	ADC1->CR |= ADC_CR_ADEN;

	// Wait the ADC to be ready.
	while (ADC1->ISR == 0);

	ADC2->CFGR &= ~ADC_CFGR_CONT;

	// Enable the ADC
	ADC2->CR |= ADC_CR_ADEN;

	// Wait the ADC to be ready.
	while (ADC2->ISR == 0);

	uint16_t value_1 = 0;
	uint16_t value_2 = 0;

    /* Loop forever */
	for(;;) {

		// request the process to start
		ADC1->CR |= ADC_CR_ADSTART;

		// Wait for the end of the first conversion
		while(!(ADC1->ISR & ADC_ISR_EOC));

		// read the first value
		value_1 = ADC1->DR;
		// Max left: 1980
		// Max right: 4096
		// Map this range to 0-1000
		uint16_t mapped_value_1 = (1000.0 / (4150.0- 1950.0)) * (value_1 - 1950.0);

		ADC2->CR |= ADC_CR_ADSTART;

		// Wait for the end of the first conversion
		while(!(ADC2->ISR & ADC_ISR_EOC));

		// read the second value
		value_2 = ADC2->DR;
		// Max forward: 2410
		// Max back: 3390
		// Map this range to 0-1000
		uint16_t mapped_value_2 = (1000.0 / (3900.0- 2200.0)) * (value_2 - 2200.0);
		mapped_value_2 = 1000 - mapped_value_2;
		if (mapped_value_2 > 1000) {
			mapped_value_2 = 0;
		}

		x_coordinate = mapped_value_1;
		y_coordinate = mapped_value_2;

		// reset the sequence flag
		ADC1->ISR |= ADC_ISR_EOS;
		ADC2->ISR |= ADC_ISR_EOS;

		sendToServos();

//		// Printing values to screen for use
//		uint8_t string_to_send[100];
//		sprintf(string_to_send, "X: %u		Y: %u\r\n", value_1, value_2);
//
//		SerialOutputString(string_to_send, &USART1_PORT);

//		uint8_t string_to_send2[100];
//		sprintf(string_to_send2, "Y: %d\r", value_2);
//
//		SerialOutputString(string_to_send2, &USART1_PORT);
	}
}

void ContinuousReadSingleChannelADC() {

	// get a pointer to the location of the LEDs
	uint8_t *led_register = ((uint8_t*)&(GPIOE->ODR)) + 1;

	// enable the clock for ADC1
	RCC->AHBENR |= RCC_AHBENR_ADC12EN;

	// set to synchronise the ADC with the clock
	ADC12_COMMON->CCR |= ADC12_CCR_CKMODE_0;

	// ADEN must be = 0 for configuration (is the default)
	ADC1->CR &= ~ADC_CR_ADVREGEN; // clear voltage regulator enable
	ADC1->CR |= ADC_CR_ADVREGEN_0; // set ADVREGEN TO 01
	ADC1->CR &= ~ADC_CR_ADCALDIF; // clear bit to enable Single-ended-input

	// calibrate the ADC (self calibration routine)
	ADC1->CR |= ADC_CR_ADCAL;
	while((ADC1->CR & ADC_CR_ADCAL) == ADC_CR_ADCAL); // Waiting for the calibration to finish

	// select the channel, only one conversion so it goes in
	//  the first conversion slot (SQ1)
	//  and the L value should be 0 (L=0000 does one conversion only)
	ADC1->SQR1 = 0; // clear any existing channel requests
	ADC1->SQR1 |= 0x02 << ADC_SQR1_SQ1_Pos; // request channel 2
	ADC1->SQR1 |= 0x00 << ADC_SQR1_L_Pos; // set the number of channels to read

	// continuous mode
	ADC1->CFGR |= ADC_CFGR_CONT;

	// Enable ADC
	ADC1->CR |= ADC_CR_ADEN;

	while (ADC1->ISR == 0); //Wait the ADC to be ready.

	// request the process to start
	// only need once in continuous mode
	ADC1->CR |= ADC_CR_ADSTART;

	ADC2->CR &= ~ADC_CR_ADVREGEN; // clear voltage regulator enable
	ADC2->CR |= ADC_CR_ADVREGEN_0; // set ADVREGEN TO 01
	ADC2->CR &= ~ADC_CR_ADCALDIF; // clear bit to enable Single-ended-input

	// calibrate the ADC (self calibration routine)
	ADC2->CR |= ADC_CR_ADCAL;
	while((ADC2->CR & ADC_CR_ADCAL) == ADC_CR_ADCAL); // Waiting for the calibration to finish

	// select the channel, only one conversion so it goes in
	//  the first conversion slot (SQ1)
	//  and the L value should be 0 (L=0000 does one conversion only)
	ADC2->SQR1 = 0; // clear any existing channel requests
	ADC2->SQR1 |= 0x02 << ADC_SQR1_SQ1_Pos; // request channel 2
	ADC2->SQR1 |= 0x00 << ADC_SQR1_L_Pos; // set the number of channels to read

	// continuous mode
	ADC2->CFGR |= ADC_CFGR_CONT;

	// Enable ADC
	ADC2->CR |= ADC_CR_ADEN;

	while (ADC2->ISR == 0); //Wait the ADC to be ready.

	// request the process to start
	// only need once in continuous mode
	ADC2->CR |= ADC_CR_ADSTART;

	uint16_t value_1 = 0;
	uint16_t value_2 = 0;

    /* Loop forever */
	for(;;) {

		// Wait for the end of conversion
		while(!(ADC1->ISR &= ADC_ISR_EOC));
		value_1 = ADC1->DR;

		while(!(ADC2->ISR &= ADC_ISR_EOC));
		value_2 = ADC2->DR;

		uint16_t mapped_value_1 = (1000.0 / (3650.0- 2800.0)) * (value_1 - 2800.0);

		uint16_t mapped_value_2 = (1000.0 / (3900.0- 2200.0)) * (value_2 - 2200.0);
		mapped_value_2 = 1000 - mapped_value_2;
		if (mapped_value_2 > 1000) {
			mapped_value_2 = 0;
		}

		x_coordinate = mapped_value_1;
		y_coordinate = mapped_value_2;

		sendToServos();

	}
}


int setup_adc(void) {
	enable_clocks();
	initialise_board();
//	SerialInitialise(BAUD_115200, &USART1_PORT, &finished_transmission);
	ContinuousReadSingleChannelADC();
}

void sendToServos() {
	// get joystick values

	// map values
	float x_pos = (float)(x_coordinate)/1000;
	float y_pos = (float)(y_coordinate)/1000;

	float x_pos_invert = 1-x_pos + 0.15;
	if (x_pos_invert > 1) {
		x_pos_invert = (float) 1.0;
	}
	else if (x_pos_invert < 0) {
		x_pos_invert = (float) 0.0;
	}

	// send axis 1 to position
	servoGoToFractionalPosition(&Servo1, x_pos + 0.1);
	servoGoToFractionalPosition(&Servo2, x_pos_invert - 0.1);  // inverse

	// send axis 2 to position
	servoGoToFractionalPosition(&Servo3, y_pos-0.1);
	servoGoToFractionalPosition(&Servo4, 1-y_pos);  // inverse
}
